<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Tachibana Shin (たちばなしん)</title>
        <link>https://shin.is-a.dev/</link>
        <description>Tachibana Shin (たちばなしん)' Blog</description>
        <lastBuildDate>Mon, 05 Sep 2022 14:39:28 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>Tachibana Shin (たちばなしん)</title>
            <url>https://shin.is-a.dev/avatar-flat.jpg</url>
            <link>https://shin.is-a.dev/</link>
        </image>
        <copyright>MIT 2022 © Tachibana Shin (たちばなしん)</copyright>
        <atom:link href="https://shin.is-a.dev/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Get information device from JavaScript]]></title>
            <link>https://shin.is-a.dev/posts/get-ip-with-js</link>
            <guid>https://shin.is-a.dev/posts/get-ip-with-js</guid>
            <pubDate>Mon, 05 Sep 2022 14:38:30 GMT</pubDate>
            <description><![CDATA[My site is now powered by Vite!]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p>You can get v4 IP info using API: <a href="http://ip-api.com/json">http://ip-api.com/json</a></p>
<p>Get IP info (v6 preferred if available) using: <a href="http://api.myip.com">http://api.myip.com</a></p>
<p>and get all IP provider information by <code>https://api.iplocation.net/?ip=&lt;IP v4 or v6&gt;</code></p>
<p>Try it:</p>
<pre><code class="language-ts">const [IPv4, IPv6] = await Promise.all([
  fetch(&quot;http://ip-api.com/json&quot;).then(res =&gt; res.json()),
  fetch(&quot;http://api.myip.com&quot;).then(res =&gt; res.json()),
])

console.log(IPv4, IPv6);

if (IPv4.query === IPv6.ip) {
  // not exists IP v6
  const info = await Promise.all([
    fetch(`https://api.iplocation.net/?ip=${IPv4.query}`).then(res =&gt; res.json()),
  ])
  
  console.log(Array.from(info));
} else {
  const info = await Promise.all([
    fetch(`https://api.iplocation.net/?ip=${IPv4.query}`).then(res =&gt; res.json()),
    fetch(`https://api.iplocation.net/?ip=${IPv6.ip}`).then(res =&gt; res.json()),
  ])
  
  console.log(Array.from(info));
}
</code></pre>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Hello My Talk]]></title>
            <link>https://shin.is-a.dev/posts/hello-talks</link>
            <guid>https://shin.is-a.dev/posts/hello-talks</guid>
            <pubDate>Wed, 19 May 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Hello my blog! This is first talk on my blog.</p>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Hello My Blog]]></title>
            <link>https://shin.is-a.dev/posts/hello</link>
            <guid>https://shin.is-a.dev/posts/hello</guid>
            <pubDate>Wed, 19 May 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Hello my blog! This is first post on my blog.</p>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Composable Vue - VueDay 2021]]></title>
            <link>https://shin.is-a.dev/posts/composable-vue-vueday-2021</link>
            <guid>https://shin.is-a.dev/posts/composable-vue-vueday-2021</guid>
            <pubDate>Wed, 28 Apr 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[Slides & transcript for my talk at VueDay 2021]]></description>
            <content:encoded><![CDATA[<p>My sharing today is Composable Vue, some pattens and tips that might be able to help you writing better composable logic in Vue.</p>
<h2><a href="https://vueuse.org/">VueUse</a></h2>
<p>It all started with me made this project called VueUse, which is a collection of Vue composable utilities. Initially, I was making this to share some of the functions I wrote with Vue Composition API to be used across apps. Till now, it grows much bigger with the community, we are now an organization on GitHub with 9 team members, 8 add-ons packages for different integrations like motions and document head management. We also have more than 100 functions in the core package that work for both Vue 2 and 3. I have really appreciated all the contributors and the awesome community.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vueuse/vueuse">vueuse/vueuse</a></p>
<p>In today's talk, I will share with you the patterns and tips that I have learned during developing VueUse and using it to make apps in Composition API.</p>
<h2>Composition API</h2>
<p>Let's have a quick look at the Composition API itself. BTW, please note today's talk will be a little bit advanced, which I would assume you already have a basic knowledge of what the Vue Composition API is. But don't worry if you don't, I believe you will still get some basic images of the methodology and you can also find the slides and transcript on my site after the talk.</p>
<h3>Ref vs Reactive <MarkerCore/></h3>
<p>Well, let's start with Ref and Reactive. I bet many of you have wondered the difference between them and which one should you choose.</p>
<p>You can think refs as variables and reactives as objects. When you do the assignment, one is assigning &quot;value&quot; while the other one is assigning properties. While the usage of them can really dependents on what you gonna use them, but if we really need to pick one from them, I'd say go with <code>ref</code> whenever you can.</p>
<p>With <code>ref</code>, you will need to use <code>.value</code> to access and assigning values, but this also gives you more explicit awareness of when you are tracking and triggering the reactivity system.</p>
<pre><code class="language-ts">import { ref } from 'vue'

let foo = 0
let bar = ref(0)

foo = 1
bar = 1 // ts-error
</code></pre>
<p>As you can see the example here, I actually got an error by accidentally assigning ref with a value, and here I can change the code to fix it.</p>
<pre><code class="language-ts">import { reactive } from 'vue'

const foo = { prop: 0 }
const bar = reactive({ prop: 0 })

foo.prop = 1
bar.prop = 1
</code></pre>
<p>On the other hand, when using <code>reactive</code> you actually can't tell the difference between a plain object and a reactive object without looking for the context, which could sometimes make the debugging a little bit harder.</p>
<p>Also note in reactive objects, there are several caveats you need to take care about. Like you can't do object destructure without <code>toRefs</code> otherwise they will lose the reactivity. And you will also need to wrap with a function when using with <code>watch</code> and so on, where <code>ref</code> does not have such limitations.</p>
<h3>Ref Auto Unwrapping <MarkerCore /></h3>
<p>When using with <code>refs</code>, a big obstacle that people facing is the annoying <code>.value</code>. But actually, in many cases, you can omit it and make your code looks cleaner.</p>
<pre><code class="language-ts">const counter = ref(0)

watch(counter, count =&gt; {
  console.log(count) // same as `counter.value`
})
</code></pre>
<p>The <code>watch</code> function accepts ref as the watch source directly, and it will return the unwrapped new value of the ref in the callback. So in this case, there is zero <code>.value</code> needed.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;counter += 1&quot;&gt;
    Counter is {\{ counter }}
  &lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>The other one is the nature of Vue, in the template, all the refs are auto unwrapped, even assignments!</p>
<pre><code class="language-ts">import { ref, reactive } from 'vue'
const foo = ref('bar')
const data = reactive({ foo, id: 10 })
data.foo // 'bar'
</code></pre>
<p>And whenever you feel like to better work with objects, you can pass the ref into the reactive object, and when you access the property, reactive will unwrap the ref automatically for you. Changes to the original ref will also reflect to the reactive object!</p>
<h3><code>unref</code> - Oppsite of Ref <MarkerCore /></h3>
<p><code>unref</code> is another Composition API I would like to introduce. As the name <code>unref</code> sounds, it's kinda the opposite of ref. While the <code>ref()</code> function takes a value and turns it into a ref, <code>unref()</code> takes a ref and returns its value.</p>
<pre><code class="language-ts">function unref&lt;T&gt;(r: Ref&lt;T&gt; | T): T {
  return isRef(r) ? r.value : r
}
</code></pre>
<p>The interesting part of it is that if you pass a plain value to <code>unref</code> it will return the value as-is to you, you can see the implementation is basically this.</p>
<pre><code class="language-ts">import { unref, ref } from 'vue'

const foo = ref('foo')
unref(foo) // 'foo'

const bar = 'bar'
unref(bar) // 'bar'
</code></pre>
<p>This is not a big feature, but a good tip to unify your logic which I will show you soon</p>
<h2>Patterns &amp; Tips</h2>
<p>That's the tips for using ref and reactive. Here I'd like to share with you some patterns of writing composable functions.</p>
<h2>What's composable Functions</h2>
<p>So what's composable functions?</p>
<p>It's actually kind of hard to give a proper definition, but I'd think it's like sets for reusable logic to make your code better organized, and separate the concerns.</p>
<pre><code class="language-ts">export function useDark(options: UseDarkOptions = {}) {
  const preferredDark = usePreferredDark()         // &lt;--
  const store = useStorage('vueuse-dark', 'auto')  // &lt;--

  return computed&lt;boolean&gt;({
    get() {
      return store.value === 'auto'
        ? preferredDark.value
        : store.value === 'dark'
    },
    set(v) {
      store.value = v === preferredDark.value 
        ? 'auto' : v ? 'dark' : 'light'
    },
  })
}
</code></pre>
<p>Here is an example, the <code>useDark</code> function in VueUse is provided as a simple toggle to enable or disable the dark mode for apps. There are actually two variables involved, one is the system's preference and one is users' manual overrides. System preference can be got using media queries, while we would also need to use localStorage to read and store the user's preference of different modes.</p>
<DarkToggleButton/>
<p>As you can see in this code snippet, I have used two other composable functions <a href="https://vueuse.org/usePreferredDark"><code>usePreferredDark</code></a> and <a href="https://vueuse.org/useStorage"><code>useStorage</code></a>, they will return two refs that reflecting on their states. Detailed things like monitoring the media query changes, the timing to read and write the storage are left to them. And all I need to do is logically composing their relationship into a single ref.</p>
<p>You can see the full code or directly use it in VueUse with the link below.</p>
<VueUseFn name="useDark"/>
<h3>Think as &quot;Connections&quot;</h3>
<p>The first methodology I want to share today is to think as &quot;connections&quot;. Unlike hooks in React that will run on each updates, the <code>setup()</code> function in Vue only runs <strong>once</strong> on component initialization, to construct the relations between your state and logic.</p>
<p>You can think the equations in mathematics, where the left hand side and right hand side are always equal. Here we have <code>z=x^2+y^2</code>, while <code>x</code> and <code>y</code> are independent variables, and <code>z</code> is a controlled variables relying on <code>x</code> and <code>y</code>. Whenever I changed any of them, <code>z</code> will be updated accordingly (DEMO). Which is also similar to the formula in spreadsheets.</p>
<p>So in composable functions, we could think arguments are input and the returns as the output. The output should be able to reflect on input changes automatically. A bit complicated? I will walk with you on that later with examples.</p>
<h3>One Thing at a Time</h3>
<p>Another aspect is to do one thing at a time - which is the same as how you write any code. No need for me to spend too much time on this, but basically they are listed here.</p>
<ul>
<li>Extract duplicated logics into composable functions</li>
<li>Have meaningful names</li>
<li>Consistent naming conversions - <code>useXX</code> <code>createXX</code> <code>onXX</code></li>
<li>Keep function small and simple</li>
<li>&quot;Do one thing, and do it well&quot;</li>
</ul>
<p>Note it's also important to have a consistent naming conversion, like prefixed with <code>useXX</code> or <code>createXX</code> and so on to make those composable functions distinguishable from other functions.</p>
<h3>Passing Ref as Arguments</h3>
<p>Alright, let's start our first pattern today - Passing refs as arguments.</p>
<pre><code class="language-ts">function add(a: number, b: number) {
  return a + b
}
</code></pre>
<pre><code class="language-ts">let a = 1
let b = 2

let c = add(a, b) // 3
</code></pre>
<p>Here we have a plain add function that sums up the two arguments <code>a</code> and <code>b</code>. You can also see the example on the right.</p>
<pre><code class="language-ts">function add(a: Ref&lt;number&gt;, b: Ref&lt;number&gt;) {
  return computed(() =&gt; a.value + b.value)
}
</code></pre>
<pre><code class="language-ts">const a = ref(1)
const b = ref(2)

const c = add(a, b)
c.value // 3
</code></pre>
<p>And then we can make this function accepting refs, and return a computed ref with their sum. Then we can pass the refs to it as we normally would with plain values. The difference here is that the returned value is also a ref, but it will always be up-to-date with the ref <code>a</code> and <code>b</code>.</p>
<pre><code class="language-ts">function add(
  a: Ref&lt;number&gt; | number,
  b: Ref&lt;number&gt; | number
) {
  return computed(() =&gt; unref(a) + unref(b))
}
</code></pre>
<pre><code class="language-ts">const a = ref(1)

const c = add(a, 5)
c.value // 6
</code></pre>
<p>And remember the <code>unref</code> function we mentioned before? We can actually make this function more flexible, by accepting both refs and plain values. And use <code>unref</code> to get their values. We can also make the addition possible between a ref and a value.</p>
<h3>MaybeRef</h3>
<pre><code class="language-ts">type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T
</code></pre>
<p>Here is a simple TypeScript's type helper called <code>MaybeRef</code> that we have used a lot in VueUse. It's a union of generic <code>T</code> and <code>Ref&lt;T&gt;</code>.</p>
<pre><code class="language-ts">export function useTimeAgo(
  time: Date | number | string | Ref&lt;Date | number | string&gt;,
) {
  return computed(() =&gt; someFormating(unref(time)))
}
</code></pre>
<pre><code class="language-ts">import { computed, unref, Ref } from 'vue'

type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T

export function useTimeAgo(
  time: MaybeRef&lt;Date | number | string&gt;,
) {
  return computed(() =&gt; someFormating(unref(time)))
}
</code></pre>
<p>In this case, we have the function useTimeAgo that accepts a wide range of Date-like types as an argument. Normally if you want to accept refs, you would need to write them again as Ref versions. With this helper, you can make the type shorter and more readable (change code). A cool point it that this works great with <code>unref</code>, it can infer the correct type for <code>MaybeRef</code>.</p>
<h3>Make it Flexible <MarkerPattern /></h3>
<p>Think your functions like LEGO, there should have many different ways of composing them for different needs.</p>
<pre><code class="language-ts">import { useTitle } from '@vueuse/core'

const title = useTitle()

title.value = 'Hello World'
// now the page's title changed
</code></pre>
<p>Here we take <code>useTitle</code> function from VueUse as an example. Basically when you call it, you will get a special ref that binds to your page's title. Whenever you change the ref's value, the page's title will also be updated. Similarly, when the page's title changed externally, the change will also be reflect to the ref's value.</p>
<p>Looks good, right? But It creates a new ref whenever you call it. To make it more flexible, we can actually bind an existing ref, even computed!</p>
<pre><code class="language-ts">import { ref, computed } from 'vue'
import { useTitle } from '@vueuse/core'

const name = ref('Hello')
const title = computed(() =&gt; {
  return `${name.value} - World`
})

useTitle(title) // Hello - World

name.value = 'Hi' // Hi - World
</code></pre>
<p>Here you can see, I constructed a computed with a ref, when I change the source ref, the computed get re-evaluated so as the page's title.</p>
<h3><code>useTitle</code> <Marker class="text-blue-400">Case</Marker></h3>
<p>You must be wondering how could this be implemented. Let's take a look at a simplified version of it.</p>
<pre><code class="language-ts">import { ref, watch } from 'vue'
import { MaybeRef } from '@vueuse/core'

export function useTitle(
  newTitle: MaybeRef&lt;string | null | undefined&gt;
) {
  const title = ref(newTitle || document.title) // &lt;-- 1

  watch(title, (t) =&gt; { // &lt;-- 2
    if (t != null)
      document.title = t
  }, { immediate: true })

  return title
}
</code></pre>
<p>It's actually only two statements! How?</p>
<p>At the first line, unified the ref from the user, or create a new one. And on the second line, it watches the changes to the ref and sync up with page's title.</p>
<p>Emm, maybe it's a little bit hard to catch on what's happened in the first line, let me explain a bit.</p>
<VueUseFn name="useTitle"/>
<h3>Reuse Refs <MarkerCore /></h3>
<p>Here, we utilized an interesting behavior of the ref function.</p>
<p>Similar to <code>unref</code> - <code>ref</code> also checks whether the passed value is ref or not. If you passed a ref to it, it will it as-is - since it's already a ref, there is no need to make another.</p>
<pre><code class="language-ts">const foo = ref(1)   // Ref&lt;1&gt;
const bar = ref(foo) // Ref&lt;1&gt;

foo === bar // true
</code></pre>
<pre><code class="language-ts">function useFoo(foo: Ref&lt;string&gt; | string) {
  // no need!
  const bar = isRef(foo) ? foo : ref(foo)

  // they are the same
  const bar = ref(foo)

  /* ... */
}
</code></pre>
<p>This could also be extremely useful in composable functions that take <code>MaybeRef</code> as argument types.</p>
<h3><code>ref</code> / <code>undef</code></h3>
<p>Let's do a quick summary so far.</p>
<ul>
<li><code>MaybeRef&lt;T&gt;</code> works well with <code>ref</code> and <code>unref</code>.</li>
<li>Use <code>ref()</code> when you want to normalized it as a Ref.</li>
<li>Use <code>unref()</code> when you want to have the value.</li>
</ul>
<pre><code class="language-ts">type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T

function useBala&lt;T&gt;(arg: MaybeRef&lt;T&gt;) {
  const reference = ref(arg) // get the ref
  const value = unref(arg)   // get the value
}
</code></pre>
<p>We can use <code>MaybeRef</code> in arguments to make the function flexible, and use <code>ref()</code> when you want to normalized it as a Ref and use <code>unref()</code> when you want to get the value. Both of them are universal and no conditions needed.</p>
<h3>Object of Refs <MarkerPattern /></h3>
<p>Another pattern today is to use objects of refs. When you need to return multiple data entries in a composable function, consider returns an object composed by refs.</p>
<pre><code class="language-ts">import { ref, reactive } from 'vue'

function useMouse() {
  return { 
    x: ref(0),
    y: ref(0)
  }
}

const { x, y } = useMouse()
const mouse = reactive(useMouse())

mouse.x === x.value // true
</code></pre>
<p>In this way, users can have the full features of ES6 object destructure. The restructure values are refs, so the reactivity still remains, and users can also rename them, or take only partial of what they want.</p>
<p>On this other hand, it's also flexible enough when users want to use it as a single object, simply wrap it with the reactive function, the refs will get unwrapped as a property automatically.</p>
<p>That said, users can get benefits from both <code>ref </code>and <code>reactive</code> as need.</p>
<h3>Async to &quot;Sync&quot; <MarkerTips /></h3>
<p>Since we are constructing &quot;connections&quot; using Composition API, we can actually make async functions to &quot;sync&quot; by building the connections first before it resolves.</p>
<pre><code class="language-ts">const data = await fetch('https://api.github.com/').then(r =&gt; r.json())

// use data
</code></pre>
<p>Let's say we want to request some data use the <code>fetch</code> API. Normally we need to <code>await</code> the request been responded and data been parsed, before we can use the data. With Composition API, we can make the data as a ref of null, then be fulfilled later.</p>
<pre><code class="language-ts">const { data } = useFetch('https://api.github.com/').json()

const user_url = computed(() =&gt; data.value?.user_url)
</code></pre>
<p>This can make your apps take the time to handle other stuff while waiting for the data to be fetched. The idea is similar to react's stale-while-revalidate, but with much easier implementation.</p>
<h3><code>useFetch</code> <Marker class="text-blue-400">Case</Marker></h3>
<p>The implementation can be simplified down to this, all you have to do is to assign the value to <code>ref</code> when the promise got resolved.</p>
<pre><code class="language-ts">export function useFetch&lt;R&gt;(url: MaybeRef&lt;string&gt;) {
  const data = shallowRef&lt;T | undefined&gt;()
  const error = shallowRef&lt;Error | undefined&gt;()

  fetch(unref(url))
    .then(r =&gt; r.json())
    .then(r =&gt; data.value = r)
    .catch(e =&gt; error.value = e)

  return {
    data,
    error
  }
}
</code></pre>
<p>In the real world, we might also need some flags to show the current state of the request, where you can find the full code in VueUse.</p>
<VueUseFn name="useFetch"/>
<h3>Side-effects Self Cleanup <MarkerPattern /></h3>
<p><code>watch</code> and <code>computed</code> functions in Vue will stop themselves automatically along with the components unmounting. We'd recommend following the same pattern for your custom composable functions.</p>
<p>By calling the <code>onUnmounted</code> hooks inside your composable functions, you can schedule the effect clean-up logic.</p>
<pre><code class="language-ts">import { onUnmounted } from 'vue'

export function useEventListener(target: EventTarget, name: string, fn: any) {
  target.addEventListener(name, fn)

  onUnmounted(() =&gt; {
    target.removeEventListener(name, fn) // &lt;--
  })
}
</code></pre>
<p>For example, it's common to use <code>addEventListener</code> to register the handler to DOM events. When you finish the usage, you would also need to remember to unregister it using <code>removeEventListener</code>. In this case, we can have a function <code>useEventListener</code> that unregister itself along with the component so you don't need to worry about it anymore.</p>
<VueUseFn name="useEventListener"/>
<h3><code>effectScope</code> RFC <Marker class="text-purple-400">Upcoming</Marker></h3>
<p>While side-effects auto clean-up is nice, sometimes you might want to have better controls over when to do that. I drafted an RFC proposing a new API called <code>effectScope</code> to collect those effects into a single instance, that you can stop them together at the time you want. This is likely to be implemented and shipped with Vue 3.1. Check out for more details if it get you interested.</p>
<pre><code class="language-ts">// effect, computed, watch, watchEffect created inside the scope will be collected

const scope = effectScope(() =&gt; {
  const doubled = computed(() =&gt; counter.value * 2)

  watch(doubled, () =&gt; console.log(double.value))

  watchEffect(() =&gt; console.log('Count: ', double.value))
})

// dispose all effects in the scope
stop(scope)
</code></pre>
<h3>Typed Provide / Inject</h3>
<p>We have a set of new APIs called <code>provide</code> and <code>inject</code>. It's basically for sharing some context for the component's children to consume and reuse. They are two separate function, which means TypeScript can't actually infer the types for each context automatically.</p>
<p>But here we have a solution for that. Vue provided a type helper called <code>InjectionKey</code> where you can define a symbol that carries the type you want, and then it will hint <code>provide</code> and <code>inject</code> to have proper autocompletion and type checking.</p>
<pre><code class="language-ts">// context.ts
import { InjectionKey } from 'vue'

export interface UserInfo {
  id: number
  name: string
}

export const injectKeyUser: InjectionKey&lt;UserInfo&gt; = Symbol()
</code></pre>
<p>For example, here I defined an interface <code>UserInfo</code> which contains two properties. And I exported a symbol with the <code>InjectionKey</code> type.</p>
<pre><code class="language-ts">// parent.vue
import { provide } from 'vue' 
import { injectKeyUser } from './context'

export default {
  setup() {
    provide(injectKeyUser, {
      id: '7', // type error: should be number
      name: 'Anthony'
    })
  }
}
</code></pre>
<p>In usage, I can use the <code>provide</code> function to provide the data with key. Can you see here I get a type error that the id should be a number. So I can catch up the error right away before it goes to production.</p>
<pre><code class="language-ts">// child.vue
import { inject } from 'vue' 
import { injectKeyUser } from './context'

export default {
  setup() {
    const user = inject(injectKeyUser) 
    // UserInfo | undefined

    if (user)
      console.log(user.name) // Anthony
  }
}
</code></pre>
<p>And in the child component, we can use the <code>inject</code> function with the key as well. You can see it correctly infers the type <code>UserInfo</code> and so as its property.</p>
<h3>Shared State <MarkerPattern /></h3>
<p>With the flexibility of Vue's Composition API, sharing state is actually quite simple.</p>
<pre><code class="language-ts">// shared.ts
import { reactive } from 'vue'

export const state = reactive({
  foo: 1,
  bar: 'Hello'
})
</code></pre>
<p>You can declare some ref or reactive state in a js module, and import them to your components. Since they are using the same instance, the state will be just in sync.</p>
<pre><code class="language-ts">// A.vue
import { state } from './shared.ts'

state.foo += 1
</code></pre>
<pre><code class="language-ts">// B.vue
import { state } from './shared.ts'

console.log(state.foo) // 2
</code></pre>
<p>But please note this is actually not SSR compatible. In SSR your server will create a new app on each request, where this approach will keep the state persistent across multiple rendering. And normally it's not what we would expect.</p>
<h3>Shared State (SSR friendly) <MarkerPattern /></h3>
<p>Let's see if we can make a solution for it to work with SSR.</p>
<pre><code class="language-ts">export const myStateKey: InjectionKey&lt;MyState&gt; = Symbol()

export function createMyState() {
  const state = {
    /* ... */
  }

  return {
    install(app: App) {
      app.provide(myStateKey, state)
    }
  }
}

export function useMyState(): MyState {
  return inject(myStateKey)!
}
</code></pre>
<p>By using <code>provide</code> and <code>inject</code>, to share the state one the App context, which means it will be created every time when the server doing the rendering. You can see here I have two function, <code>createMyState</code> and <code>useMyState</code>. <code>createMyState</code> will returns a Vue plugin that provide the state to the App. While <code>useMyState</code> is just a wrapper of <code>inject</code> using the same key.</p>
<pre><code class="language-ts">// main.ts
const App = createApp(App)

app.use(createMyState())
</code></pre>
<pre><code class="language-ts">// A.vue

// use everywhere in your app
const state = useMyState()
</code></pre>
<p>In usage, we can create the state in the main entry and pass it to <code>app.use</code>. Then you can use the hook <code>useMyState</code> everywhere in your components.</p>
<p>If you have ever tried Vue Router v4, it actually uses a similar method to do that like <code>createRouter</code> and `useRouter.</p>
<h3>useVModel <MarkerTips /></h3>
<p>One last tip I'd like to share is a utility called <code>useVModel</code>.</p>
<pre><code class="language-ts">export function useVModel(props, name) {
  const emit = getCurrentInstance().emit

  return computed({
    get() {
      return props[name]
    },
    set(v) {
      emit(`update:${name}`, v)
    }
  })
}
</code></pre>
<p>It's just a simple wrapper to the component model to bind with <code>props</code> and <code>emit</code>. This is actually a lifesaver to me.</p>
<pre><code class="language-ts">export default defineComponent({
  setup(props) {
    const value = useVModel(props, 'value')

    return { value }
  }
})
</code></pre>
<p>We can take a look at the code, you can see we used a writable computed. When accessing the value, we forward the value of props to it, and when writing, we emit out the update event automatically so you can use just like a normal ref.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;input v-model=&quot;value&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>Even more, we can actually bind into our children elements's <code>v-model</code> very easily.</p>
<VueUseFn name="useVModel"/>
<h2>Vue 2 &amp; 3</h2>
<p>That's all the tips and patterns I have for today.</p>
<p>As you might think those are for Vue 3 only, but actually they also applies for Vue 2!</p>
<h3><code>@vue/composition-api</code> <Marker class="text-teal-400">Lib</Marker></h3>
<p>In case you didn't know that, if you are still on Vue 2 but want to start using the Composition API, here we offered an official plugin that enables the Composition API for your Vue 2 app. Give it a try if you haven't.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vuejs/composition-api">vuejs/composition-api</a></p>
<pre><code class="language-ts">import Vue from 'vue'
import VueCompositionAPI from '@vue/composition-api'

Vue.use(VueCompositionAPI)
</code></pre>
<pre><code class="language-ts">import { ref, reactive } from '@vue/composition-api'
</code></pre>
<h3>Vue 2.7 <Marker class="text-purple-400">Upcoming</Marker></h3>
<p>We also announced <a href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md#for-those-who-absolutely-need-ie11-support">our plan for Vue 2.7</a> recently. Vue 2.7 will be the last minor version of Vue 2 with long time support for existing projects and those who still need IE 11 support. We will back-port Vue 3's new features to Vue 2.7 and migrate the <code>@vue/compositon-api</code> plugin into it. Stay tuned on that.</p>
<ul>
<li>Backport <code>@vue/composition-api</code> into Vue 2's core.</li>
<li><code>&lt;script setup&gt;</code> syntax in Single-File Components.</li>
<li>Migrate codebase to TypeScript.</li>
<li>IE11 support.</li>
<li>LTS.</li>
</ul>
<h3>Vue Demi <Marker class="text-teal-400">Lib</Marker></h3>
<p>If you are a library author want your libraries to support Vue 2 and 3 with the same codebase. You can try Vue Demi, which eases out the difference between Vue 2 and 3 and auto-detects users' environment.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vueuse/vue-demi">vueuse/vue-demi</a></p>
<pre><code class="language-ts">// same syntax for both Vue 2 and 3
import { ref, reactive, defineComponent } from 'vue-demi'
</code></pre>
<h2>Thank you!</h2>
<p>That's all for today.</p>
<p>Due to the time limit, it's a shame that I can not share all I have learned with you. As the Vue composition API is still fairly new, I believe there are more patterns and better practices for us to found.</p>
<p>To find more information, do check out the <a href="https://github.com/vueuse">VueUse org on GitHub</a> and <a href="https://vueuse.org/add-ons.html">its awesome ecosystem</a>, and follow us on Twitter <a href="https://twitter.com/vueuse">@vueuse</a> to keep up-to-date with news and tips.</p>
<p>Thank you!</p>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Rewrite in Vite]]></title>
            <link>https://shin.is-a.dev/posts/rewrite-in-vite</link>
            <guid>https://shin.is-a.dev/posts/rewrite-in-vite</guid>
            <pubDate>Sun, 31 Jan 2021 16:00:00 GMT</pubDate>
            <description><![CDATA[My site is now powered by Vite!]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p>The page you are looking at is now powered by <a href="https://github.com/vitejs/vite">Vite</a>. This is something I want to do for a long while since Vite came out, and it's finally done. As I have mentioned in my <a href="/posts/new-house">first blog post</a>, it was powered <a href="https://gridsome.org/">Gridsome</a> using Vue 2. With this overhaul, I can now take full advantage of Vue 3 and the <a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a> with the new <a href="https://github.com/vuejs/rfcs/pull/227"><code>&lt;script setup&gt;</code> SFC style</a>.</p>
<p>The reason for it taking me so long to do this is because I am busy (enjoy) doing <a href="https://americanexpress.io/yak-shaving">yak shaving</a>, for the tools I need to build this site.</p>
<h3>Dark Mode</h3>
<p>Dark mode is supported as an experimental feature in Tailwind CSS v1.8 and shipped in v2.0. It supports two modes for you to choose from - <code>media</code> and <code>class</code>. <code>media</code> is something that works out-of-box, it changes based on users' system preference. But the limitation is that you can't toggle it manually as you want. So I went with <code>class</code> mode where I have more controls over it. But that also means I would need to implement the toggling logic myself.</p>
<p>With the power of Vue's Composition API, I am able to combine the best parts of them - reactive to the system's preference while being able to override manually.</p>
<pre><code class="language-ts">import { useStorage, usePreferredDark } from '@vueuse/core'

const preferredDark = usePreferredDark()
const colorSchema = useStorage('color-schema', 'auto')

export const isDark = computed({
  get() {
    return colorSchema.value === 'auto'
      ? preferredDark.value
      : colorSchema.value === 'dark'
  },
  set(v: boolean) {
    if (v === preferredDark.value)
      colorSchema.value = 'auto'
    else
      colorSchema.value = v ? 'dark' : 'light'
  },
})

watch(
  isDark,
  v =&gt; document.documentElement.classList.toggle('dark', v),
  { immediate: true },
)
</code></pre>
<p>Click it to try 👇🏼</p>
<ToggleTheme class="text-2xl pb-2 pt-1"/>
<p>If you would like to use it in your own apps, I also extract the logic above into <a href="https://vueuse.js.org/core/usedark/"><code>useDark()</code> in VueUse</a>. Where you can simply use like this:</p>
<pre><code class="language-ts">import { useDark, useToggle } from '@vueuse/core'

const isDark = useDark()
const toggleDark = useToggle(isDark)
</code></pre>
<h3>Markdown</h3>
<p>After building Icônes, I started working on the <a href="http://codecember.ink/">Codecember</a> project with <a href="https://blog.matsu.io/about">@octref</a>, an initiative of learning and creating generative arts in December. With the spirit of dogfooding, we chosen Vite for building the site. In Codecember we will need to have a prompt every day with some texts, code snippets, and demos. This comes with the problem that Vite does not have a plugin for handling markdown files at that moment, so of course, I made one myself.</p>
<ul>
<li><a href="https://github.com/antfu/vite-plugin-md">vite-plugin-md</a> - Markdown for Vite.</li>
</ul>
<p>Basically, it uses <a href="https://markdown-it.github.io/"><code>markdown-it</code></a> to transform markdown into HTML and feed it into Vue's template compiler. As the generated template is handled by Vue, we can easily support Vue components inside Markdown.</p>
<h3>Syntax Highlighting</h3>
<p>Getting syntax highlight works in dark mode isn't an easy task as well. <a href="https://github.com/shikijs/shiki">Shiki</a> inlined all the colors into the HTML so you would not be bored by the CSS namespace pollution, but that also means it will be really hard to get the colors aware of your global color scheme. <a href="https://prismjs.com/">Prism</a> on the other hand, uses the classes combining the CSS theme to do the job. It's easier to merge two color schemes and make them aware of the <code>dark</code> trigger. The bad thing is, themes are often wrote by different authors with different styles of coloring and styling things. Sometimes, even the font and spacing could be different across different themes. If you ever ran into a similar situation, you should know what I mean. If you don't (lucky you!), see <a href="https://github.com/PrismJS/prism-themes/tree/master/themes">Prism's themes collection</a>(<a href="https://github.com/PrismJS/prism-themes/blob/c24ddffde2737293d9b2df7dc59939d527648863/themes/prism-vs.css#L9"><code>prism-vs.css</code></a> and <a href="https://github.com/PrismJS/prism-themes/blob/c24ddffde2737293d9b2df7dc59939d527648863/themes/prism-vsc-dark-plus.css#L6"><code>prism-vsc-dark-plus.css</code></a> for example).</p>
<p>Fight with them for a while you might be able to ease the misalignment eventually. But what if we can have a smarter way to do this?</p>
<ul>
<li><a href="https://github.com/antfu/prism-theme-vars">prism-theme-vars</a> - A customizable Prism.js theme using CSS variables.</li>
</ul>
<p>Instead of dealing with the lengthy CSS theme, now you can have one in less than 20 lines of CSS variables. For example:</p>
<pre><code class="language-css">@import &quot;prism-theme-vars/base.css&quot;;

:root {
  --prism-foreground: #393a34;
  --prism-background: #fbfbfb;
  --prism-comment: #b8c4b8;
  --prism-string: #c67b5d;
  --prism-literal: #3a9c9b;
  --prism-keyword: #248459;
  --prism-function: #849145;
  --prism-deleted: #a14f55;
  --prism-class: #2b91af;
  --prism-builtin: #a52727;
  --prism-property: #ad502b;
  --prism-namespace: #c96880;
  --prism-punctuation: #8e8f8b;
}
</code></pre>
<p>To have it supports dark mode is extremely simple as well:</p>
<pre><code class="language-css">html:not(.dark) {
  --prism-foreground: #393a34;
  --prism-background: #f8f8f8;
  --prism-comment: #758575;
  --prism-namespace: #444444;
  --prism-string: #bc8671;
  --prism-punctuation: #80817d;
  --prism-literal: #36acaa;
  --prism-keyword: #248459;
  --prism-function: #849145;
  --prism-deleted: #9a050f;
  --prism-class: #2b91af;
  --prism-builtin: #800000;
}

html.dark {
  --prism-foreground: #d4d4d4;
  --prism-background: #1e1e1e;
  --prism-namespace: #aaaaaa;
  --prism-comment: #758575;
  --prism-namespace: #444444;
  --prism-string: #ce9178;
  --prism-punctuation: #d4d4d4;
  --prism-literal: #36acaa;
  --prism-keyword: #38a776;
  --prism-function: #dcdcaa;
  --prism-deleted: #9a050f;
  --prism-class: #4ec9b0;
  --prism-builtin: #d16969;
}
</code></pre>
<p>That's all. You can also play with the themes in the <a href="https://prism-theme-vars.netlify.app/">Playground</a> and make some your own within 5 mins. I created my first code theme in my life using it, which is also exactly what you are looking at :)</p>
<h3>Serve-Side Generatation (SSG)</h3>
<p>While Codecember is more like a site than an app, we would need to do some server-side generation to improve our <a href="https://searchengineland.com/guide/what-is-seo">SEO</a>. Read quite a lot of code from <a href="https://github.com/vuejs/vitepress">VitePress</a>, I came up with this plugin:</p>
<ul>
<li><a href="https://github.com/antfu/vite-ssg">vite-ssg</a> - Server-side generation for Vite.</li>
</ul>
<p>The idea here is fairly simple: bundle the app entry, then for each route, dump the app using APIs from the <a href="https://github.com/vuejs/vue-next/tree/master/packages/server-renderer"><code>@vue/server-renderer</code></a> package. Simplified code here:</p>
<pre><code class="language-ts">import { renderToString } from '@vue/server-renderer'

const createApp = required('dist-ssr/app.js')

await Promise.all(
  routes.map(async(route) =&gt; {
    const { app, router, head } = createApp(false)

    router.push(route)
    await router.isReady()

    const appHTML = await renderToString(app)
    const renderedHTML = renderHTML(indexHTML, appHTML)

    await fs.writeFile(`${route}.html`, renderedHTML, 'utf-8')
  })
)
</code></pre>
<p>The full code can be found <a href="https://github.com/antfu/vite-ssg/blob/fa256449923e05e55bf15dcf4747d517bc22e33a/src/node/build.ts#L94-L104">here</a>.</p>
<p>With the <a href="https://github.com/vueuse/head">@vueuse/head</a> package made by <a href="https://github.com/egoist">@egoist</a>, I made the document head/meta manipulation in SSG with ease. Combining with <a href="https://github.com/antfu/vite-plugin-md">vite-plugin-md</a>, you can even use the frontmatter to set the meta (title, description, og:image, etc.).</p>
<pre><code class="language-html">&lt;script setup&gt;
import { useHead } from '@vueuse/head'

useHead({
  title: 'Website Title',
  meta: [
    {
      name: 'description',
      content: 'Website description',
    },
  ],
})
&lt;/script&gt;
</code></pre>
<h3>The Vite Template</h3>
<p>I found myself making small web apps frequently. Setting up plugins and configs for Vite kinda becomes the bottleneck for me to make my idea landded. So combining with those tools I am using, I made an opinionated template for myself but unexpectedly got quite some good feedback:</p>
<ul>
<li><a href="https://github.com/antfu/vitesse">Vitesse</a> - Opinionated Vite Starter Template</li>
</ul>
<h2>This Website</h2>
<p>This site is <strong>made from <a href="https://github.com/antfu/vitesse">Vitesse</a> combining with all the tools I mentioned above</strong>. To be honest, even making a static site generator right is something hard to me, not to mention that most of the hard parts are already handled by Vite. I am really happy to see so many things I have learned and crafted along the way. And glad I can make these contributions to the Vite ecosystem, that someone could find my work useful for building their apps.</p>
<h2>Thanks</h2>
<p>I can't make all these happened without the help/support from the great community, thank y'all!</p>
<p>Also want to have some special thanks to people made significant contributions towards these projects 🙌 (A-Z)</p>
<ul>
<li><a href="https://github.com/hannoeru">@hannoeru</a></li>
<li><a href="https://github.com/matias-capeletto">@matias-capeletto</a></li>
<li><a href="https://github.com/privatenumber">@privatenumber</a></li>
<li><a href="https://github.com/sibbng">@sibbng</a></li>
</ul>
<p>And thank you for reading through!</p>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Watch with @vue/reactivity]]></title>
            <link>https://shin.is-a.dev/posts/watch-with-reactivity</link>
            <guid>https://shin.is-a.dev/posts/watch-with-reactivity</guid>
            <pubDate>Fri, 18 Sep 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[A brief intro of how it works and a guide to implementing the (missing) `watch` on your own.]]></description>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p><a href="https://twitter.com/tachib_shin/status/1298667080804233221">As you probably know</a>, the things I excited most in Vue 3 are the <a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a> and the <a href="https://v3.vuejs.org/guide/reactivity.html">reactivity system</a>. With the Composition API we can reuse logics and states across components or even apps. What's better? The underhood reactivity system is decoupled from Vue, which means you can use it almost everywhere, even without UI.</p>
<p>Here are some proof of concepts for using the reactivity system outside of Vue:</p>
<ul>
<li>
<p><a href="https://github.com/yyx990803/vue-lit"><code>@vue/lit</code></a> is a minimal framework wrote by Evan combining <a href="https://github.com/vuejs/vue-next/tree/master/packages/reactivity"><code>@vue/reactivity</code></a> and <a href="https://lit-html.polymer-project.org/"><code>lit-html</code></a>. It can run directly in browsers, with the almost identical experience as Vue Composition API.</p>
</li>
<li>
<p><a href="https://github.com/antfu/reactivue"><code>ReactiVue</code></a> ports Vue Composition API to React. It also provides React's lifecycles in the Vue style.</p>
</li>
</ul>
<p>Furthermore, you can even use Vue's libraries in them. Tested with <a href="https://github.com/antfu/vueuse"><code>VueUse</code></a> and <a href="https://github.com/posva/pinia"><code>pinia</code></a> in <a href="https://github.com/antfu/reactivue"><code>ReactiVue</code></a>, and they just work. You can find <a href="https://github.com/antfu/reactivue#using-vues-libraries">more details and examples here</a>.</p>
<p>I am also experimenting more possibility of Vue reactivity in other scenarios. It's currently a WIP private repo, but keep tuned, I get more to come 😉!</p>
<h2>Understanding <code>@vue/reactivity</code></h2>
<p>&quot;reactive objects&quot; returned by <code>ref()</code> or <code>reactive()</code> are actually <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a>. Those proxies will trigger some actions to track the changes on properties accessing or writing.</p>
<p>For a simplified example,</p>
<pre><code class="language-ts">const reactive = (target) =&gt; new Proxy(target, {
  get(target, prop, receiver) {
    track(target, prop)
    return Reflect.get(...arguments) // get the original data
  },
  set(target, key, value, receiver) {
    trigger(target, key)
    return Reflect.set(...arguments) // set the original data
  }
})

const obj = reactive({
  hello: 'world'
})

console.log(obj.hello) // `track()` get called
obj.hello = 'vue' // `trigger()` get called
</code></pre>
<p>So in this way, vue can be notified when those properties get accessed or when they be modified.</p>
<blockquote>
<p>For more detailed explanations, check out the <a href="https://v3.vuejs.org/guide/reactivity.html#what-is-reactivity">official docs</a></p>
</blockquote>
<h3>Computed</h3>
<p>Since we are able to know those events, we can start diving into the <code>computed</code> which is where the &quot;reactive&quot; magic start shining.</p>
<p><code>computed</code> is like a getter that auto collects the reactive dependencies source and auto re-evaluate when they get changed.</p>
<p>For example,</p>
<pre><code class="language-ts">const counter = ref(1)
const multiplier = ref(2)

const result = computed(() =&gt; counter.value * multiplier.value)

console.log(result.value) // 2
counter.value += 1
console.log(result.value) // 4
</code></pre>
<p>To know how the <code>computed</code> work, we need to dig into the lower level API <code>effect</code> first.</p>
<h2>Effect</h2>
<p><code>effect</code> is a new API introduced in Vue 3. Underneath, it's the engine powers the &quot;reactivity&quot; in <code>computed</code> and <code>watch</code>. For the most of the time, you don't need to directly use it. But knowing it well helps you understand the reactivity system much easier.</p>
<p><code>effect</code> takes the first argument as the <code>getter</code> and a second argument for the options. The <code>getter</code> is the function that collect its deps on each run via their <code>track()</code> hooks. The field <code>scheduler</code> in options provides a way to invoke a custom function when the deps change.</p>
<p>So basically, you can write a simple <code>computed</code> on your own like:</p>
<pre><code class="language-ts">const computed = (getter) =&gt; {
  let value
  let dirty = true
  
  const runner = effect(getter, {
    lazy: true,
    scheduler() {
      dirty = true // deps changed
    }
  })
  
  // return should be a `Ref` in real world, simplified here
  return {
    get value() {
      if (dirty) {
        value = runner() // re-evaluate
        dirty = false
      }
      return value
    }
  }
}
</code></pre>
<p>If you really interested in how it works in Vue, check out <a href="https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/computed.ts">the source code here</a></p>
<h2>Build yourself a <code>watch</code></h2>
<p>We have done the most important APIs in <code>@vue/reactivity</code> now, which is <code>ref</code> <code>reactive</code> <code>effect</code> <code>computed</code>.</p>
<p>Oh wait, we are missing the <code>watch</code> here!</p>
<pre><code class="language-js">import { watch } from '@vue/reactivity' // does NOT exist!
</code></pre>
<p>If you take a look at Vue 3's source code, you will find that <code>watch</code> is actually <a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/apiWatch.ts">implemented in <code>@vue/runtime-core</code></a>, along with the Vue's component model and lifecycles. The main reason for this is that <code>watch</code> is deep bound with the component's lifecycles (auto dispose, invalidate, etc.). But it shouldn't be the thing to keep you from using it outside of Vue.</p>
<p>Let's implement the <code>watch</code> our own!</p>
<h3>The Basic</h3>
<p>Let's take a look at Vue's watch interface first</p>
<pre><code class="language-ts">const count = ref(0)

watch(
  () =&gt; count.value,
  (newValue) =&gt; {
    console.log(`count changed to: ${newValue}!`)
  }
)

count.value = 2
// count changed to: 2!
</code></pre>
<p>With the knowledge of <code>effect</code>, it's quite straight forward to implement</p>
<pre><code class="language-ts">const watch = (getter, fn) =&gt; {
  const runner = effect(getter, {
    lazy: true,
    scheduler: fn
  }
  
  // a callback function is returned to stop the effect
  return () =&gt; stop(runner)
}
</code></pre>
<p>Watch is lazy by default in Vue, you can add the third options to give control to the users.</p>
<h3>Watch for Ref</h3>
<p>You may also notice that the Vue's <code>watch</code> also allows passing the ref directly to it.</p>
<pre><code class="language-ts">watch(
  count,
  () =&gt; { /* onChanged */ }
)
</code></pre>
<p>For that, just wrap it into a getter will do</p>
<pre><code class="language-ts">const watch = (source, fn) =&gt; {
  const getter = isRef(source)
    ? () =&gt; source.value
    : source

  const runner = effect(getter, {
    lazy: true,
    scheduler: fn
  }

  return () =&gt; stop(runner)
}
</code></pre>
<h3>Watch Deeply</h3>
<p>One other great feature about <code>watch</code> is that it allows you to watch on deep changes.</p>
<pre><code class="language-ts">const state = reactive({
  info: {
    name: 'Anthony',
  }
})

watch(state, () =&gt; { console.log('changed!') }, { deep: true })

state.info.name = 'Tachibana Shin (たちばなしん)'
// changed!
</code></pre>
<p>To implement this feature, you need to collect the <code>track()</code> events on every nested property. We can achieve that with a <code>traverse</code> function.</p>
<pre><code class="language-ts">function traverse(value, seen = new Set()) {
  if (!isObject(value) || seen.has(value))
    return value

  seen.add(value) // prevent circular reference 
  if (isArray(value)) {
    for (let i = 0; i &lt; value.length; i++)
      traverse(value[i], seen)
  }
  else {
    for (const key of Object.keys(value))
      traverse(value[key], seen)
  }
  return value
}

const watch = (source, fn, { deep, lazy = true }) =&gt; {
  let getter = isRef(source)
    ? () =&gt; source.value
    : isReactive(source) 
      ? () =&gt; source
      : source
    
  if (deep)
    getter = () =&gt; traverse(getter())
    
  const runner = effect(getter, {
    lazy,
    scheduler: fn
  }

  return () =&gt; stop(runner)
}
</code></pre>
<p>Done! The thing left to do is to polish, adding overloads to make it more flexible, add more options to get better control, and handle some edge cases. Then you should get yourself a good start for using a custom <code>watch</code>!</p>
<h2>Lifecycles</h2>
<p>In Vue, <code>computed</code> and <code>watch</code> will automatically bind their <code>effect</code> runner to the current component instance. When the component get unmounted, the effects bond to it will be auto disposed. More specially, you can read <a href="https://github.com/vuejs/vue-next/blob/985bd2bcb5fd8bccd1c15c8c5d89a6919fd73922/packages/runtime-core/src/apiWatch.ts#L294">the source code here</a>.</p>
<p>Since we don't have an instance, if you want to stop those effects, you have to do them manually. When you have multiple effects in used, to stop them together, you have to manually collect them together. One easier way is to mock similar lifecycles like Vue. This requires some amount of works, I will explain that in another blog post. Please keep tuned.</p>
<h2>Take Away</h2>
<p>Thanks for reading! And hope it is helpful for you to understand and better play with the Vue reactivity system. If you want to have the <code>watch</code> outside of Vue, I made one for you (much more robust than the examples above for sure).</p>
<pre class="block language-bash">
yarn add <a href='https://github.com/antfu/vue-reactivity-watch' target='_blank'>@vue-reactivity/watch</a>
</pre> 
<p>Have fun ;P</p>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Type Inferencing in Vue]]></title>
            <link>https://shin.is-a.dev/posts/type-inferencing-in-vue</link>
            <guid>https://shin.is-a.dev/posts/type-inferencing-in-vue</guid>
            <pubDate>Sun, 28 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>[[toc]]</p>
<p>As you may or may not know, I am working on preparing to release the v1.0 version for <a href="https://github.com/vuejs/composition-api">@vue/composition-api</a> recently. One of the current problems is that the type inference does not play well <a href="https://github.com/vuejs/composition-api/issues/338">#338</a>. So I get a chance to have a deeper look at <a href="https://github.com/vuejs/composition-api">vue-next</a>'s type implementations. I will tell you what I learned and how magic works in Vue.</p>
<p>Forget about the <code>setup()</code> function and <code>Composition API</code> for now, let talk about the options API in Vue 2 that everybody familiar with. In a classical example, we would have <code>data</code>, <code>computed</code>, <code>methods</code> and some other fields like this:</p>
<pre><code class="language-js">export default {
  data: {
    first_name: &quot;Anthony&quot;,
    last_name: &quot;Fu&quot;,
  },
  computed: {
    full_name() {
      return this.first_name + &quot; &quot; + this.last_name
    },
  },
  methods: {
    hi() {
      alert(this.full_name)
    }
  }
}
</code></pre>
<p>It works well in Javascript and putting all the context into <code>this</code> is pretty straightforward and easy to understand. But when you switch to TypeScript for static type checking. <code>this</code> will not be the context you expected. How can we make the types work for Vue like the example above?</p>
<h2>Type for <code>this</code></h2>
<p>To explicitly assign the type to <code>this</code>, we can simply use the <code>this parameter</code>:</p>
<pre><code class="language-ts">interface Context {
  $injected: string
}

function bar(this: Context, a: number) {
  this.$injected // ok
}
</code></pre>
<p>The limitation of this approach is that we will lose the signature of the method when working with a dict of methods:</p>
<pre><code class="language-ts">type Methods = Record&lt;string, (this: Context, ...args:any[]) =&gt; any&gt;

const methods: Methods = {
  bar(a: number) {
    this.$injected // ok
  }
}

methods.bar('foo', 'bar') // no error, the type of arguments becomes `any[]`
</code></pre>
<p>We would not want to ask users to explicitly type <code>this</code> in every method in order to make the type checking works.<br>
So we will need another approach.</p>
<h3><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet"><code>ThisType</code></a></h3>
<p>After digging into Vue's code, I found an interesting TypeScirpt utility <code>ThisType</code>. The official doc says:</p>
<blockquote>
<p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual <code>this</code> type.</p>
</blockquote>
<p><code>ThisType</code> would affect all the nested functions. With it, we can have:</p>
<pre><code class="language-ts">type Methods = {
  double: (a: number) =&gt; number
  deep: {
    nested: {
      half: (a: number) =&gt; number
    }
  }
}

const methods: Methods &amp; ThisType&lt;Methods &amp; Context&gt; = {
  double(a: number) {
    this.$injected // ok
    return a * 2
  },
  deep: {
    nested: {
      half(a: number) {
        this.$injected // ok
        return a / 2
      }
    }
  }
}

methods.double(2) // ok
methods.double('foo') // error
methods.deep.nested.half(4) // ok
</code></pre>
<p>The typing works well, but it still requires users to define the type interface of Methods first. Can we make it infer itself automatically?</p>
<p>We can do that with function inference:</p>
<pre><code class="language-ts">type Options&lt;T&gt; = {
  methods?: T 
} &amp; ThisType&lt;T &amp; Context&gt;

function define&lt;T&gt;(options: Options&lt;T&gt;) {
  return options
}

define({
  methods: {
    foo() {
      this.$injected // ok
    },
  },
})
</code></pre>
<p>There is only one step left, to make context object dynamic inference from <code>data</code> and <code>computed</code>.</p>
<p>The full working demo would be:</p>
<pre><code class="language-ts">/* ---- Type ---- */
export type ExtractComputedReturns&lt;T extends any&gt; = {
  [key in keyof T]: T[key] extends (...args: any[]) =&gt; infer TReturn
    ? TReturn
    : never
}

type Options&lt;D = {}, C = {}, M = {}&gt; = {
  data: () =&gt; D
  computed: C
  methods: M
  mounted: () =&gt; void
  // and other options
} 
&amp; ThisType&lt;D &amp; M &amp; ExtractComputedReturns&lt;C&gt;&gt; // merge them together

function define&lt;D, C, M&gt;(options: Options&lt;D, C, M&gt;) {}

/* ---- Usage ---- */
define({
  data() {
    return {
      first_name: &quot;Anthony&quot;,
      last_name: &quot;Fu&quot;,
    }
  },
  computed: {
    fullname() {
      return this.first_name + &quot; &quot; + this.last_name
    },
  },
  methods: {
    notify(msg: string) {
      alert(msg)
    }
  },
  mounted() {
    this.notify(this.fullname)
  },
})
</code></pre>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
        <item>
            <title><![CDATA[Domain Email]]></title>
            <link>https://shin.is-a.dev/posts/domain-email</link>
            <guid>https://shin.is-a.dev/posts/domain-email</guid>
            <pubDate>Wed, 17 Jun 2020 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Saw <a href="https://twitter.com/youyuxi/status/1272932071749619712">a tweet from Evan You</a> about the <a href="https://hey.com/">hey.com</a> mail service recently. I got interested in having a short and nice email address. My current one in Hotmail is just too long to even being spell out in talk. <code>hey.com</code> looks very nice but $99/year is not a very good deal to me. I decide to use my own domain for receiving emails.</p>
<p>I did this a couple years ago for another domain, I kinda remember an open-source tool allowing forwarding emails by just adding DNS record. I took some time to search for it but I didn't find the page matches with my memory. I went GitHub to search in my stared projects, it turns out the tool now becomes and Freemium SaaS <a href="https://forwardemail.net/">forwardemail.net</a> with a fresh new logo and website design that I can't even recognize it.</p>
<p>The DNS forwarding feature just works the same, but it requires you to log in and register your domain now. I am glad it now being more well documented and charging for premium supports which can help it sustain.</p>
<p>The config is quite simple as usual, just 3 DNS record:</p>
<pre><code class="language-html">MX   @  mx1.forwardemail.net  10
MX   @  mx2.forwardemail.net  20
TXT  @  forward-email=youremail@example.com
</code></pre>
<p>That’s it! It also provides some advanced configs, you can check <a href="https://forwardemail.net/en/faq">the doc here</a>.</p>
<p>While setting up and reading the docs, I learned that you can explicitly purge the cache for <a href="https://1.1.1.1/purge-cache/">Cloudflare DNS</a> and <a href="https://developers.google.com/speed/public-dns/cache">Google DNS</a>. That's a very good-to-know tip!</p>
]]></content:encoded>
            <author>thanhnguyennguyen1995@gmail.com (Tachibana Shin)</author>
        </item>
    </channel>
</rss>